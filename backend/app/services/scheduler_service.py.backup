from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from typing import List

from app.database import SessionLocal
from app.models import AutomationConfig, Company, Campaign, Message, CompanyEmail, CompanyPhone
from app.enums import MessageType, MessageStage, MessageStatus
from app.services.gpt_service import gpt_service
from app.services.gemini_service import gemini_service
from app.services.email_service import email_service
from app.services.automation_service import unsubscribe_service, reply_tracking_service
from app.services.google_search_service import google_search_service


class SchedulerService:
    """Background job scheduler for automation."""
    
    def __init__(self):
        self.scheduler = AsyncIOScheduler()
    
    def start(self):
        """Start the scheduler and register all jobs."""
        # Daily company fetch - runs at 2 AM
        self.scheduler.add_job(
            self.daily_company_fetch_job,
            'cron',
            hour=2,
            minute=0,
            id='daily_company_fetch'
        )
        
        # Daily campaign generation - runs at 3 AM
        self.scheduler.add_job(
            self.daily_campaign_generation_job,
            'cron',
            hour=3,
            minute=0,
            id='daily_campaign_generation'
        )
        
        # Message sender - runs every 30 minutes
        self.scheduler.add_job(
            self.message_sender_job,
            'interval',
            minutes=30,
            id='message_sender'
        )
        
        # Reply checker - runs every hour
        self.scheduler.add_job(
            self.reply_checker_job,
            'interval',
            hours=1,
            id='reply_checker'
        )
        
        self.scheduler.start()
        print("✅ Scheduler started successfully")
                    print(f"❌ Error fetching companies for {config.industry}: {str(e)}")
                    db.rollback()
        
        finally:
            db.close()
    
    async def daily_campaign_generation_job(self):
        """Generate campaigns for newly fetched companies."""
        print(f"[{datetime.now()}] Running daily campaign generation job...")
        
        db = SessionLocal()
        try:
            # Get all active automation configs
            configs = db.query(AutomationConfig).filter(
                AutomationConfig.is_active == True
            ).all()
            
            for config in configs:
                # Get companies fetched in last 24 hours for this config
                yesterday = datetime.utcnow() - timedelta(days=1)
                new_companies = db.query(Company).filter(
                    Company.industry == config.industry,
                    Company.country == config.country,
                    Company.created_at >= yesterday
                ).all()
                
                if not new_companies:
                    print(f"No new companies for {config.industry} in {config.country}")
                    continue
                
                # Create campaign
                campaign_name = f"{config.country} {config.industry} - {datetime.utcnow().strftime('%Y-%m-%d')}"
                campaign = Campaign(
                    name=campaign_name,
                    industry=config.industry
                )
                db.add(campaign)
                db.commit()
                
                print(f"Created campaign: {campaign_name}")
                
                # Generate messages for each company
                for company in new_companies:
                    try:
                        # Generate content using GPT
                        email_content = gpt_service.generate_outreach_content(
                            company_name=company.name,
                            industry=company.industry,
                            country=company.country,
                            platform="email",
                            stage="initial"
                        )
                        
                        whatsapp_content = gpt_service.generate_outreach_content(
                            company_name=company.name,
                            industry=company.industry,
                            country=company.country,
                            platform="whatsapp",
                            stage="initial"
                        )
                        
                        # Get send times
                        now = datetime.utcnow()
                        today_send_time = now.replace(hour=config.send_time_hour, minute=0, second=0, microsecond=0)
                        if today_send_time < now:
                            today_send_time += timedelta(days=1)
                        
                        # Create 6 messages (3 email + 3 whatsapp)
                        messages = [
                            # Email messages
                            Message(
                                company_id=company.id,
                                campaign_id=campaign.id,
                                type=MessageType.EMAIL,
                                stage=MessageStage.INITIAL,
                                content=email_content.get("email", ""),
                                subject=email_content.get("subject", "Business Opportunity"),
                                status=MessageStatus.DRAFT,
                                scheduled_for=today_send_time
                            ),
                            Message(
                                company_id=company.id,
                                campaign_id=campaign.id,
                                type=MessageType.EMAIL,
                                stage=MessageStage.FOLLOWUP_1,
                                content=email_content.get("email", ""),
                                subject=f"Re: {email_content.get('subject', 'Follow-up')}",
                                status=MessageStatus.DRAFT,
                                scheduled_for=today_send_time + timedelta(days=config.followup_day_1)
                            ),
                            Message(
                                company_id=company.id,
                                campaign_id=campaign.id,
                                type=MessageType.EMAIL,
                                stage=MessageStage.FOLLOWUP_2,
                                content=email_content.get("email", ""),
                                subject=f"Re: {email_content.get('subject', 'Final follow-up')}",
                                status=MessageStatus.DRAFT,
                                scheduled_for=today_send_time + timedelta(days=config.followup_day_2)
                            ),
                            # WhatsApp messages
                            Message(
                                company_id=company.id,
                                campaign_id=campaign.id,
                                type=MessageType.WHATSAPP,
                                stage=MessageStage.INITIAL,
                                content=whatsapp_content.get("whatsapp", ""),
                                status=MessageStatus.DRAFT,
                                scheduled_for=today_send_time
                            ),
                            Message(
                                company_id=company.id,
                                campaign_id=campaign.id,
                                type=MessageType.WHATSAPP,
                                stage=MessageStage.FOLLOWUP_1,
                                content=whatsapp_content.get("whatsapp", ""),
                                status=MessageStatus.DRAFT,
                                scheduled_for=today_send_time + timedelta(days=config.followup_day_1)
                            ),
                            Message(
                                company_id=company.id,
                                campaign_id=campaign.id,
                                type=MessageType.WHATSAPP,
                                stage=MessageStage.FOLLOWUP_2,
                                content=whatsapp_content.get("whatsapp", ""),
                                status=MessageStatus.DRAFT,
                                scheduled_for=today_send_time + timedelta(days=config.followup_day_2)
                            ),
                        ]
                        
                        for msg in messages:
                            db.add(msg)
                        
                        db.commit()
                        print(f"✅ Generated messages for {company.name}")
                        
                    except Exception as e:
                        print(f"❌ Error generating messages for {company.name}: {str(e)}")
                        db.rollback()
                
        finally:
            db.close()
    
    async def message_sender_job(self):
        """Send scheduled messages."""
        print(f"[{datetime.now()}] Running message sender job...")
        
        db = SessionLocal()
        try:
            now = datetime.utcnow()
            
            # Get messages that are due to be sent
            messages = db.query(Message).filter(
                Message.status == MessageStatus.DRAFT,
                Message.scheduled_for <= now
            ).limit(100).all()  # Process 100 at a time
            
            if not messages:
                print("No messages to send")
                return
            
            print(f"Found {len(messages)} messages to send")
            
            for message in messages:
                try:
                    # Get company
                    company = db.query(Company).filter(Company.id == message.company_id).first()
                    if not company or not company.email:
                        message.status = MessageStatus.FAILED
                        db.commit()
                        continue
                    
                    # Check if unsubscribed
                    if unsubscribe_service.is_unsubscribed(db, company.email):
                        message.status = MessageStatus.FAILED
                        db.commit()
                        print(f"Skipped {company.name} - unsubscribed")
                        continue
                    
                    # Check if replied
                    if reply_tracking_service.has_replied(db, company.id):
                        message.status = MessageStatus.FAILED
                        db.commit()
                        print(f"Skipped {company.name} - already replied")
                        continue
                    
                    # Send based on type
                    if message.type == MessageType.EMAIL:
                        html_content = email_service.format_html_email(
                            message.content,
                            message.subject,
                            unsubscribe_token=message.unsubscribe_token
                        )
                        
                        result = await email_service.send_email_async(
                            to_email=company.email,
                            subject=message.subject or "Business Inquiry",
                            content=html_content,
                            html=True
                        )
                        
                        if result['status'] == 'sent':
                            message.status = MessageStatus.SENT
                            message.sent_at = datetime.utcnow()
                            db.commit()
                            print(f"✅ Sent email to {company.name}")
                        else:
                            message.status = MessageStatus.FAILED
                            db.commit()
                            print(f"❌ Failed to send email to {company.name}: {result.get('error')}")
                    
                except Exception as e:
                    print(f"❌ Error sending message to {company.name}: {str(e)}")
                    message.status = MessageStatus.FAILED
                    db.commit()
        
        finally:
            db.close()
    
    async def reply_checker_job(self):
        """Check for email replies using IMAP."""
        print(f"[{datetime.now()}] Running reply checker job...")
        
        from app.services.imap_service import imap_service
        
        db = SessionLocal()
        try:
            # Get replies from inbox
            replies = await imap_service.check_for_replies()
            
            if not replies:
                print("No new replies found")
                return
            
            print(f"Found {len(replies)} new replies")
            
            for reply in replies:
                from_email = reply['from_email'].lower()
                
                # Find company by email
                company = db.query(Company).filter(
                    Company.email == from_email
                ).first()
                
                if company:
                    # Record reply
                    reply_tracking_service.record_reply(
                        db=db,
                        company_id=company.id,
                        from_email=from_email,
                        subject=reply.get('subject'),
                        reply_content=reply.get('content')
                    )
                    print(f"✅ Recorded reply from {company.name}")
        
        except Exception as e:
            print(f"❌ Error checking replies: {str(e)}")
        
        finally:
            db.close()


# Global instance
scheduler_service = SchedulerService()
